<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="import java.util.Properties&#10;import java.io.FileInputStream&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    alias(libs.plugins.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.stonecode.mapsroutepicker&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.stonecode.mapsroutepicker&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // Read API key from local.properties&#10;        val localProperties = Properties()&#10;        val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;        if (localPropertiesFile.exists()) {&#10;            localPropertiesFile.inputStream().use { stream -&gt;&#10;                localProperties.load(stream)&#10;            }&#10;        }&#10;&#10;        val mapsApiKey: String = localProperties.getProperty(&quot;MAPS_API_KEY&quot;) ?: &quot;&quot;&#10;&#10;        // Log for debugging (will show in build output)&#10;        println(&quot; MAPS_API_KEY loaded: ${if (mapsApiKey.isNotEmpty()) mapsApiKey.take(10) + &quot;...&quot; else &quot;EMPTY!&quot;}&quot;)&#10;&#10;        if (mapsApiKey.isEmpty()) {&#10;            throw GradleException(&quot;❌ MAPS_API_KEY not found in local.properties!&quot;)&#10;        }&#10;&#10;        // Expose API key to BuildConfig&#10;        buildConfigField(&quot;String&quot;, &quot;MAPS_API_KEY&quot;, &quot;\&quot;$mapsApiKey\&quot;&quot;)&#10;&#10;        // Also add to AndroidManifest&#10;        manifestPlaceholders[&quot;MAPS_API_KEY&quot;] = mapsApiKey&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = libs.versions.composeCompiler.get()&#10;    }&#10;    buildFeatures {&#10;        compose = true        // Jetpack Compose UI&#10;        buildConfig = true    // For BuildConfig.MAPS_API_KEY&#10;    }&#10;}&#10;&#10;dependencies {&#10;    constraints {&#10;        implementation(&quot;com.squareup:javapoet:1.13.0&quot;) {&#10;            because(&quot;Hilt's processors require ClassName.canonicalName() from newer JavaPoet&quot;)&#10;        }&#10;    }&#10;&#10;    // Core Android&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.gms.play.services.maps)&#10;&#10;    // Jetpack Compose&#10;    val composeBom = platform(libs.compose.bom)&#10;    implementation(composeBom)&#10;    implementation(libs.compose.ui)&#10;    implementation(libs.compose.ui.graphics)&#10;    implementation(libs.compose.ui.tooling.preview)&#10;    implementation(libs.compose.material3)&#10;    implementation(libs.compose.material.icons.extended)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.androidx.lifecycle.runtime.compose)&#10;    debugImplementation(libs.compose.ui.tooling)&#10;&#10;    // Google Maps &amp; Location&#10;    implementation(libs.play.services.maps)&#10;    implementation(libs.play.services.location)&#10;    implementation(libs.maps.compose)&#10;    implementation(libs.maps.compose.utils)&#10;    implementation(libs.maps.utils)&#10;&#10;    // Networking&#10;    implementation(libs.retrofit)&#10;    implementation(libs.retrofit.converter.gson)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.okhttp.logging.interceptor)&#10;    implementation(libs.gson)&#10;&#10;    // Dependency Injection&#10;    implementation(libs.hilt.android)&#10;    ksp(libs.hilt.compiler)&#10;    implementation(libs.hilt.navigation.compose)&#10;&#10;    // Coroutines&#10;    implementation(libs.kotlinx.coroutines.android)&#10;    implementation(libs.kotlinx.coroutines.play.services)&#10;&#10;    // Permissions&#10;    implementation(libs.accompanist.permissions)&#10;&#10;    // Lifecycle (keep existing)&#10;    implementation(libs.androidx.lifecycle.livedata.ktx)&#10;    implementation(libs.androidx.lifecycle.viewmodel.ktx)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}&#10;" />
              <option name="updatedContent" value="import java.util.Properties&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    alias(libs.plugins.ksp)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.stonecode.mapsroutepicker&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.stonecode.mapsroutepicker&quot;&#10;        minSdk = 24&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // Read API key from local.properties&#10;        val localProperties = Properties()&#10;        val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;        if (localPropertiesFile.exists()) {&#10;            localPropertiesFile.inputStream().use { stream -&gt;&#10;                localProperties.load(stream)&#10;            }&#10;        }&#10;&#10;        val mapsApiKey: String = localProperties.getProperty(&quot;MAPS_API_KEY&quot;) ?: &quot;&quot;&#10;&#10;        // Log for debugging (will show in build output)&#10;        println(&quot; MAPS_API_KEY loaded: ${if (mapsApiKey.isNotEmpty()) mapsApiKey.take(10) + &quot;...&quot; else &quot;EMPTY!&quot;}&quot;)&#10;&#10;        if (mapsApiKey.isEmpty()) {&#10;            throw GradleException(&quot;❌ MAPS_API_KEY not found in local.properties!&quot;)&#10;        }&#10;&#10;        // Expose API key to BuildConfig&#10;        buildConfigField(&quot;String&quot;, &quot;MAPS_API_KEY&quot;, &quot;\&quot;$mapsApiKey\&quot;&quot;)&#10;&#10;        // Also add to AndroidManifest&#10;        manifestPlaceholders[&quot;MAPS_API_KEY&quot;] = mapsApiKey&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = libs.versions.composeCompiler.get()&#10;    }&#10;    buildFeatures {&#10;        compose = true        // Jetpack Compose UI&#10;        buildConfig = true    // For BuildConfig.MAPS_API_KEY&#10;    }&#10;}&#10;&#10;dependencies {&#10;    constraints {&#10;        implementation(&quot;com.squareup:javapoet:1.13.0&quot;) {&#10;            because(&quot;Hilt's processors require ClassName.canonicalName() from newer JavaPoet&quot;)&#10;        }&#10;    }&#10;&#10;    // Core Android&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.gms.play.services.maps)&#10;&#10;    // Jetpack Compose&#10;    val composeBom = platform(libs.compose.bom)&#10;    implementation(composeBom)&#10;    implementation(libs.compose.ui)&#10;    implementation(libs.compose.ui.graphics)&#10;    implementation(libs.compose.ui.tooling.preview)&#10;    implementation(libs.compose.material3)&#10;    implementation(libs.compose.material.icons.extended)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.androidx.lifecycle.runtime.compose)&#10;    debugImplementation(libs.compose.ui.tooling)&#10;&#10;    // Google Maps &amp; Location&#10;    implementation(libs.play.services.maps)&#10;    implementation(libs.play.services.location)&#10;    implementation(libs.maps.compose)&#10;    implementation(libs.maps.compose.utils)&#10;    implementation(libs.maps.utils)&#10;&#10;    // Networking&#10;    implementation(libs.retrofit)&#10;    implementation(libs.retrofit.converter.gson)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.okhttp.logging.interceptor)&#10;    implementation(libs.gson)&#10;&#10;    // Dependency Injection&#10;    implementation(libs.hilt.android)&#10;    ksp(libs.hilt.compiler)&#10;    implementation(libs.hilt.navigation.compose)&#10;&#10;    // Coroutines&#10;    implementation(libs.kotlinx.coroutines.android)&#10;    implementation(libs.kotlinx.coroutines.play.services)&#10;&#10;    // Permissions&#10;    implementation(libs.accompanist.permissions)&#10;&#10;    // Lifecycle (keep existing)&#10;    implementation(libs.androidx.lifecycle.livedata.ktx)&#10;    implementation(libs.androidx.lifecycle.viewmodel.ktx)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/stonecode/mapsroutepicker/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/stonecode/mapsroutepicker/MainActivity.kt" />
              <option name="originalContent" value="package com.stonecode.mapsroutepicker&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.stonecode.mapsroutepicker.ui.map.MapScreen&#10;import com.stonecode.mapsroutepicker.ui.theme.MapsRoutePickerTheme&#10;import dagger.hilt.android.AndroidEntryPoint&#10;&#10;@AndroidEntryPoint&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            MapsRoutePickerTheme {&#10;                MapScreen()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun DefaultPreview() {&#10;    MapsRoutePickerTheme {&#10;        Text(&quot;Maps Route Picker&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.stonecode.mapsroutepicker&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import com.stonecode.mapsroutepicker.ui.map.MapScreen&#10;import com.stonecode.mapsroutepicker.ui.theme.MapsRoutePickerTheme&#10;import dagger.hilt.android.AndroidEntryPoint&#10;&#10;@AndroidEntryPoint&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            MapsRoutePickerTheme {&#10;                MapScreen()&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun DefaultPreview() {&#10;    MapsRoutePickerTheme {&#10;        Text(&quot;Maps Route Picker&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/stonecode/mapsroutepicker/ui/map/MapScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/stonecode/mapsroutepicker/ui/map/MapScreen.kt" />
              <option name="originalContent" value="package com.stonecode.mapsroutepicker.ui.map&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.accompanist.permissions.isGranted&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory&#10;import com.google.android.gms.maps.model.CameraPosition&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.maps.android.compose.*&#10;import com.stonecode.mapsroutepicker.ui.permissions.LocationPermissionHandler&#10;import com.stonecode.mapsroutepicker.ui.map.components.WaypointTimeline&#10;import com.stonecode.mapsroutepicker.ui.map.components.MapControlFabs&#10;import com.stonecode.mapsroutepicker.ui.map.components.SwipeableRouteInfoCard&#10;import com.stonecode.mapsroutepicker.ui.map.components.getWaypointColor&#10;import com.stonecode.mapsroutepicker.util.PolylineDecoder&#10;&#10;/**&#10; * Main map screen - displays Google Map with route, waypoints, and controls&#10; */&#10;@OptIn(ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun MapScreen(&#10;    viewModel: MapViewModel = hiltViewModel()&#10;) {&#10;    val state by viewModel.state.collectAsState()&#10;&#10;    // Debug: Log API key at runtime&#10;    LaunchedEffect(Unit) {&#10;        val apiKey = com.stonecode.mapsroutepicker.BuildConfig.MAPS_API_KEY&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; API Key in app: ${apiKey.take(10)}...&quot;)&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; Current location: ${state.currentLocation}&quot;)&#10;    }&#10;&#10;    LocationPermissionHandler(&#10;        onPermissionGranted = {&#10;            viewModel.onEvent(MapEvent.RequestLocationPermission)&#10;        },&#10;        onPermissionDenied = {&#10;            // Permission not granted, map will still work but without location&#10;        }&#10;    ) { permissionState -&gt;&#10;        if (!permissionState.allPermissionsGranted) {&#10;            // Show permission rationale&#10;            PermissionRationaleContent(&#10;                onRequestPermission = { permissionState.launchMultiplePermissionRequest() }&#10;            )&#10;        } else {&#10;            // Show main map content with system bar padding&#10;            Box(modifier = Modifier.fillMaxSize()) {&#10;                MapContent(state = state, viewModel = viewModel)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PermissionRationaleContent(&#10;    onRequestPermission: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(16.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Location Permission Required&quot;,&#10;                style = MaterialTheme.typography.headlineSmall&#10;            )&#10;            Text(&#10;                text = &quot;This app needs location access to show your current position and provide navigation.&quot;,&#10;                style = MaterialTheme.typography.bodyMedium&#10;            )&#10;            Button(onClick = onRequestPermission) {&#10;                Text(&quot;Grant Permission&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun MapContent(&#10;    state: MapState,&#10;    viewModel: MapViewModel&#10;) {&#10;    var showInitialHint by remember { mutableStateOf(true) }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Main Google Map&#10;        GoogleMapView(&#10;            state = state,&#10;            onMapTapped = { location -&gt;&#10;                viewModel.onEvent(MapEvent.MapTapped(location))&#10;                showInitialHint = false // Dismiss hint after first tap&#10;            }&#10;        )&#10;&#10;        // Top waypoint timeline - only show when waypoints exist&#10;        if (state.waypoints.isNotEmpty()) {&#10;            WaypointTimeline(&#10;                waypoints = state.waypoints,&#10;                onRemoveWaypoint = { waypointId -&gt;&#10;                    viewModel.onEvent(MapEvent.RemoveWaypoint(waypointId))&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .fillMaxWidth()&#10;                    .statusBarsPadding()&#10;                    .padding(16.dp)&#10;            )&#10;        }&#10;&#10;        // Initial hint - dismissible, reappears if context changes&#10;        if (state.error == null &amp;&amp; showInitialHint &amp;&amp; state.destination == null &amp;&amp; state.waypoints.isEmpty()) {&#10;            DismissibleInitialHint(&#10;                onDismiss = { showInitialHint = false },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .statusBarsPadding()&#10;                    .padding(16.dp)&#10;                    .fillMaxWidth()&#10;            )&#10;        }&#10;&#10;        // Bottom-right FAB stack (My Location + Compass + Close button)&#10;        MapControlFabs(&#10;            onMyLocationClick = {&#10;                // Animate camera to current location&#10;                state.currentLocation?.let { location -&gt;&#10;                    viewModel.onEvent(MapEvent.AnimateToLocation(location))&#10;                }&#10;            },&#10;            onCloseClick = {&#10;                viewModel.onEvent(MapEvent.ClearRoute)&#10;                showInitialHint = true // Show hint again after clearing&#10;            },&#10;            showCloseButton = state.destination != null || state.waypoints.isNotEmpty(),&#10;            modifier = Modifier&#10;                .align(Alignment.BottomEnd)&#10;                .navigationBarsPadding()&#10;                .padding(16.dp)&#10;                .padding(bottom = if (state.route != null &amp;&amp; state.error == null) 80.dp else 0.dp) // Extra padding when route card is visible&#10;        )&#10;&#10;        // Loading indicator with message&#10;        if (state.isLoading) {&#10;            LoadingOverlay()&#10;        }&#10;&#10;        // Error message - improved dismissible card&#10;        state.error?.let { error -&gt;&#10;            ErrorCard(&#10;                error = error,&#10;                onDismiss = { viewModel.onEvent(MapEvent.DismissError) },&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomCenter)&#10;                    .navigationBarsPadding()&#10;                    .padding(16.dp)&#10;                    .fillMaxWidth()&#10;            )&#10;        }&#10;&#10;        // Route info card (bottom) - only show when no error - with swipe-to-reveal close&#10;        if (state.error == null) {&#10;            state.route?.let { route -&gt;&#10;                SwipeableRouteInfoCard(&#10;                    route = route,&#10;                    onClose = {&#10;                        viewModel.onEvent(MapEvent.ClearRoute)&#10;                        showInitialHint = true&#10;                    },&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomStart) // Changed from BottomCenter to BottomStart for swipe&#10;                        .navigationBarsPadding()&#10;                        .padding(start = 16.dp, end = 16.dp, bottom = 16.dp)&#10;                        .fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun GoogleMapView(&#10;    state: MapState,&#10;    onMapTapped: (LatLng) -&gt; Unit&#10;) {&#10;    // Default camera position (San Francisco)&#10;    val defaultLocation = LatLng(37.7749, -122.4194)&#10;    val cameraPositionState = rememberCameraPositionState {&#10;        position = CameraPosition.fromLatLngZoom(&#10;            state.currentLocation ?: defaultLocation,&#10;            12f&#10;        )&#10;    }&#10;&#10;    // Debug: Log when map is being composed&#10;    LaunchedEffect(Unit) {&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot;️ GoogleMap composable being rendered&quot;)&#10;    }&#10;&#10;    // Animate to current location when it changes and map is loaded&#10;    LaunchedEffect(state.currentLocation) {&#10;        state.currentLocation?.let { location -&gt;&#10;            cameraPositionState.animate(&#10;                update = CameraUpdateFactory.newLatLngZoom(location, 15f),&#10;                durationMs = 1000&#10;            )&#10;        }&#10;    }&#10;&#10;    GoogleMap(&#10;        modifier = Modifier.fillMaxSize(),&#10;        cameraPositionState = cameraPositionState,&#10;        properties = MapProperties(&#10;            isMyLocationEnabled = state.hasLocationPermission&#10;        ),&#10;        uiSettings = MapUiSettings(&#10;            myLocationButtonEnabled = false, // Use custom FAB instead&#10;            zoomControlsEnabled = false,&#10;            compassEnabled = false // Moved to custom controls&#10;        ),&#10;        onMapClick = { location -&gt;&#10;            Log.d(&quot;MapsRoutePicker&quot;, &quot; Map tapped at: $location&quot;)&#10;            onMapTapped(location)&#10;        },&#10;        onMapLoaded = {&#10;            Log.d(&quot;MapsRoutePicker&quot;, &quot;✅ Map loaded successfully!&quot;)&#10;        }&#10;    ) {&#10;        // Destination marker&#10;        state.destination?.let { destination -&gt;&#10;            Marker(&#10;                state = MarkerState(position = destination),&#10;                title = &quot;Destination&quot;,&#10;                snippet = &quot;Your destination&quot;,&#10;                icon = BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED)&#10;            )&#10;        }&#10;&#10;        // Waypoint markers with labels (A, B, C...)&#10;        state.waypoints.sortedBy { it.order }.forEachIndexed { index, waypoint -&gt;&#10;            Marker(&#10;                state = MarkerState(position = waypoint.location),&#10;                title = &quot;Waypoint ${('A' + index)}&quot;,&#10;                snippet = &quot;Tap to remove&quot;,&#10;                icon = BitmapDescriptorFactory.defaultMarker(getMarkerHue(index))&#10;            )&#10;        }&#10;&#10;        // Color-coded route polylines for each segment&#10;        state.route?.let { route -&gt;&#10;            if (state.waypoints.isEmpty()) {&#10;                // Simple single-color route when no waypoints&#10;                val polylinePoints = PolylineDecoder.decode(route.overviewPolyline)&#10;                Polyline(&#10;                    points = polylinePoints,&#10;                    color = Color(0xFF4285F4), // Google Blue&#10;                    width = 12f&#10;                )&#10;            } else {&#10;                // Multi-colored route segments for each waypoint&#10;                route.legs.forEachIndexed { index, leg -&gt;&#10;                    leg.steps.forEach { step -&gt;&#10;                        val segmentPoints = PolylineDecoder.decode(step.polyline)&#10;                        val segmentColor = getWaypointColor(index)&#10;                        Polyline(&#10;                            points = segmentPoints,&#10;                            color = segmentColor,&#10;                            width = 12f&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Convert waypoint color to Google Maps marker hue (0-360)&#10; */&#10;private fun getMarkerHue(index: Int): Float {&#10;    val hues = listOf(&#10;        0f,    // Red&#10;        210f,  // Blue&#10;        120f,  // Green&#10;        45f,   // Orange/Amber&#10;        270f,  // Purple&#10;        30f,   // Orange&#10;        180f,  // Cyan&#10;        0f,    // Dark Red&#10;        270f,  // Deep Purple&#10;        180f   // Teal&#10;    )&#10;    return hues[index % hues.size]&#10;}&#10;&#10;@Composable&#10;private fun DismissibleInitialHint(&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.95f)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp, vertical = 12.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot; Tap anywhere on the map to set your destination&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                textAlign = TextAlign.Start,&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;            IconButton(&#10;                onClick = onDismiss,&#10;                modifier = Modifier.size(32.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;×&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RouteInfoCard(&#10;    route: com.stonecode.mapsroutepicker.domain.model.Route,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface // Solid background for contrast&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(16.dp)&#10;        ) {&#10;            Text(&#10;                text = route.summary ?: &quot;Route&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                color = MaterialTheme.colorScheme.onSurface&#10;            )&#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            Row(&#10;                horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot; ${route.getFormattedDistance()}&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;                Text(&#10;                    text = &quot;⏱️ ${route.getFormattedDuration()}&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LoadingOverlay() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.95f)&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                CircularProgressIndicator()&#10;                Text(&#10;                    text = &quot;Calculating route...&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ErrorCard(&#10;    error: String,&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.errorContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            verticalAlignment = Alignment.Top&#10;        ) {&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;⚠️ Error&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = error,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;&#10;                // Add helpful hints based on error type&#10;                if (error.contains(&quot;API key&quot;, ignoreCase = true)) {&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot; Fix: Run tools/fix_api_key.sh in WSL to create a valid API key&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onErrorContainer.copy(alpha = 0.8f)&#10;                    )&#10;                }&#10;            }&#10;            IconButton(onClick = onDismiss) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = &quot;Dismiss error&quot;,&#10;                    tint = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.stonecode.mapsroutepicker.ui.map&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory&#10;import com.google.android.gms.maps.model.CameraPosition&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.maps.android.compose.*&#10;import com.stonecode.mapsroutepicker.ui.permissions.LocationPermissionHandler&#10;import com.stonecode.mapsroutepicker.ui.map.components.WaypointTimeline&#10;import com.stonecode.mapsroutepicker.ui.map.components.MapControlFabs&#10;import com.stonecode.mapsroutepicker.ui.map.components.SwipeableRouteInfoCard&#10;import com.stonecode.mapsroutepicker.ui.map.components.getWaypointColor&#10;import com.stonecode.mapsroutepicker.util.PolylineDecoder&#10;&#10;/**&#10; * Main map screen - displays Google Map with route, waypoints, and controls&#10; */&#10;@OptIn(ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun MapScreen(&#10;    viewModel: MapViewModel = hiltViewModel()&#10;) {&#10;    val state by viewModel.state.collectAsState()&#10;&#10;    // Debug: Log API key at runtime&#10;    LaunchedEffect(Unit) {&#10;        val apiKey = com.stonecode.mapsroutepicker.BuildConfig.MAPS_API_KEY&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; API Key in app: ${apiKey.take(10)}...&quot;)&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; Current location: ${state.currentLocation}&quot;)&#10;    }&#10;&#10;    LocationPermissionHandler(&#10;        onPermissionGranted = {&#10;            viewModel.onEvent(MapEvent.RequestLocationPermission)&#10;        },&#10;        onPermissionDenied = {&#10;            // Permission not granted, map will still work but without location&#10;        }&#10;    ) { permissionState -&gt;&#10;        if (!permissionState.allPermissionsGranted) {&#10;            // Show permission rationale&#10;            PermissionRationaleContent(&#10;                onRequestPermission = { permissionState.launchMultiplePermissionRequest() }&#10;            )&#10;        } else {&#10;            // Show main map content with system bar padding&#10;            Box(modifier = Modifier.fillMaxSize()) {&#10;                MapContent(state = state, viewModel = viewModel)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PermissionRationaleContent(&#10;    onRequestPermission: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(16.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Location Permission Required&quot;,&#10;                style = MaterialTheme.typography.headlineSmall&#10;            )&#10;            Text(&#10;                text = &quot;This app needs location access to show your current position and provide navigation.&quot;,&#10;                style = MaterialTheme.typography.bodyMedium&#10;            )&#10;            Button(onClick = onRequestPermission) {&#10;                Text(&quot;Grant Permission&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun MapContent(&#10;    state: MapState,&#10;    viewModel: MapViewModel&#10;) {&#10;    var showInitialHint by remember { mutableStateOf(true) }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Main Google Map&#10;        GoogleMapView(&#10;            state = state,&#10;            onMapTapped = { location -&gt;&#10;                viewModel.onEvent(MapEvent.MapTapped(location))&#10;                showInitialHint = false // Dismiss hint after first tap&#10;            }&#10;        )&#10;&#10;        // Top waypoint timeline - only show when waypoints exist&#10;        if (state.waypoints.isNotEmpty()) {&#10;            WaypointTimeline(&#10;                waypoints = state.waypoints,&#10;                onRemoveWaypoint = { waypointId -&gt;&#10;                    viewModel.onEvent(MapEvent.RemoveWaypoint(waypointId))&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .fillMaxWidth()&#10;                    .statusBarsPadding()&#10;                    .padding(16.dp)&#10;            )&#10;        }&#10;&#10;        // Initial hint - dismissible, reappears if context changes&#10;        if (state.error == null &amp;&amp; showInitialHint &amp;&amp; state.destination == null &amp;&amp; state.waypoints.isEmpty()) {&#10;            DismissibleInitialHint(&#10;                onDismiss = { showInitialHint = false },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .statusBarsPadding()&#10;                    .padding(16.dp)&#10;                    .fillMaxWidth()&#10;            )&#10;        }&#10;&#10;        // Bottom-right FAB stack (My Location + Compass + Close button)&#10;        MapControlFabs(&#10;            onMyLocationClick = {&#10;                // Animate camera to current location&#10;                state.currentLocation?.let { location -&gt;&#10;                    viewModel.onEvent(MapEvent.AnimateToLocation(location))&#10;                }&#10;            },&#10;            onCloseClick = {&#10;                viewModel.onEvent(MapEvent.ClearRoute)&#10;                showInitialHint = true // Show hint again after clearing&#10;            },&#10;            showCloseButton = state.destination != null || state.waypoints.isNotEmpty(),&#10;            modifier = Modifier&#10;                .align(Alignment.BottomEnd)&#10;                .navigationBarsPadding()&#10;                .padding(16.dp)&#10;                .padding(bottom = if (state.route != null &amp;&amp; state.error == null) 80.dp else 0.dp) // Extra padding when route card is visible&#10;        )&#10;&#10;        // Loading indicator with message&#10;        if (state.isLoading) {&#10;            LoadingOverlay()&#10;        }&#10;&#10;        // Error message - improved dismissible card&#10;        state.error?.let { error -&gt;&#10;            ErrorCard(&#10;                error = error,&#10;                onDismiss = { viewModel.onEvent(MapEvent.DismissError) },&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomCenter)&#10;                    .navigationBarsPadding()&#10;                    .padding(16.dp)&#10;                    .fillMaxWidth()&#10;            )&#10;        }&#10;&#10;        // Route info card (bottom) - only show when no error - with swipe-to-reveal close&#10;        if (state.error == null) {&#10;            state.route?.let { route -&gt;&#10;                SwipeableRouteInfoCard(&#10;                    route = route,&#10;                    onClose = {&#10;                        viewModel.onEvent(MapEvent.ClearRoute)&#10;                        showInitialHint = true&#10;                    },&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomStart) // Changed from BottomCenter to BottomStart for swipe&#10;                        .navigationBarsPadding()&#10;                        .padding(start = 16.dp, end = 16.dp, bottom = 16.dp)&#10;                        .fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun GoogleMapView(&#10;    state: MapState,&#10;    onMapTapped: (LatLng) -&gt; Unit&#10;) {&#10;    // Default camera position (San Francisco)&#10;    val defaultLocation = LatLng(37.7749, -122.4194)&#10;    val cameraPositionState = rememberCameraPositionState {&#10;        position = CameraPosition.fromLatLngZoom(&#10;            state.currentLocation ?: defaultLocation,&#10;            12f&#10;        )&#10;    }&#10;&#10;    // Debug: Log when map is being composed&#10;    LaunchedEffect(Unit) {&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot;️ GoogleMap composable being rendered&quot;)&#10;    }&#10;&#10;    // Animate to current location when it changes and map is loaded&#10;    LaunchedEffect(state.currentLocation) {&#10;        state.currentLocation?.let { location -&gt;&#10;            cameraPositionState.animate(&#10;                update = CameraUpdateFactory.newLatLngZoom(location, 15f),&#10;                durationMs = 1000&#10;            )&#10;        }&#10;    }&#10;&#10;    GoogleMap(&#10;        modifier = Modifier.fillMaxSize(),&#10;        cameraPositionState = cameraPositionState,&#10;        properties = MapProperties(&#10;            isMyLocationEnabled = state.hasLocationPermission&#10;        ),&#10;        uiSettings = MapUiSettings(&#10;            myLocationButtonEnabled = false, // Use custom FAB instead&#10;            zoomControlsEnabled = false,&#10;            compassEnabled = false // Moved to custom controls&#10;        ),&#10;        onMapClick = { location -&gt;&#10;            Log.d(&quot;MapsRoutePicker&quot;, &quot; Map tapped at: $location&quot;)&#10;            onMapTapped(location)&#10;        },&#10;        onMapLoaded = {&#10;            Log.d(&quot;MapsRoutePicker&quot;, &quot;✅ Map loaded successfully!&quot;)&#10;        }&#10;    ) {&#10;        // Destination marker&#10;        state.destination?.let { destination -&gt;&#10;            Marker(&#10;                state = MarkerState(position = destination),&#10;                title = &quot;Destination&quot;,&#10;                snippet = &quot;Your destination&quot;,&#10;                icon = BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED)&#10;            )&#10;        }&#10;&#10;        // Waypoint markers with labels (A, B, C...)&#10;        state.waypoints.sortedBy { it.order }.forEachIndexed { index, waypoint -&gt;&#10;            Marker(&#10;                state = MarkerState(position = waypoint.location),&#10;                title = &quot;Waypoint ${('A' + index)}&quot;,&#10;                snippet = &quot;Tap to remove&quot;,&#10;                icon = BitmapDescriptorFactory.defaultMarker(getMarkerHue(index))&#10;            )&#10;        }&#10;&#10;        // Color-coded route polylines for each segment&#10;        state.route?.let { route -&gt;&#10;            if (state.waypoints.isEmpty()) {&#10;                // Simple single-color route when no waypoints&#10;                val polylinePoints = PolylineDecoder.decode(route.overviewPolyline)&#10;                Polyline(&#10;                    points = polylinePoints,&#10;                    color = Color(0xFF4285F4), // Google Blue&#10;                    width = 12f&#10;                )&#10;            } else {&#10;                // Multi-colored route segments for each waypoint&#10;                route.legs.forEachIndexed { index, leg -&gt;&#10;                    leg.steps.forEach { step -&gt;&#10;                        val segmentPoints = PolylineDecoder.decode(step.polyline)&#10;                        val segmentColor = getWaypointColor(index)&#10;                        Polyline(&#10;                            points = segmentPoints,&#10;                            color = segmentColor,&#10;                            width = 12f&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Convert waypoint color to Google Maps marker hue (0-360)&#10; */&#10;private fun getMarkerHue(index: Int): Float {&#10;    val hues = listOf(&#10;        0f,    // Red&#10;        210f,  // Blue&#10;        120f,  // Green&#10;        45f,   // Orange/Amber&#10;        270f,  // Purple&#10;        30f,   // Orange&#10;        180f,  // Cyan&#10;        0f,    // Dark Red&#10;        270f,  // Deep Purple&#10;        180f   // Teal&#10;    )&#10;    return hues[index % hues.size]&#10;}&#10;&#10;@Composable&#10;private fun DismissibleInitialHint(&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.95f)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp, vertical = 12.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot; Tap anywhere on the map to set your destination&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                textAlign = TextAlign.Start,&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;            IconButton(&#10;                onClick = onDismiss,&#10;                modifier = Modifier.size(32.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;×&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LoadingOverlay() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.95f)&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                CircularProgressIndicator()&#10;                Text(&#10;                    text = &quot;Calculating route...&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ErrorCard(&#10;    error: String,&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.errorContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            verticalAlignment = Alignment.Top&#10;        ) {&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;⚠️ Error&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = error,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;&#10;                // Add helpful hints based on error type&#10;                if (error.contains(&quot;API key&quot;, ignoreCase = true)) {&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot; Fix: Run tools/fix_api_key.sh in WSL to create a valid API key&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onErrorContainer.copy(alpha = 0.8f)&#10;                    )&#10;                }&#10;            }&#10;            IconButton(onClick = onDismiss) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = &quot;Dismiss error&quot;,&#10;                    tint = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>