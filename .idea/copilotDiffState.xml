<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/stonecode/mapsroutepicker/ui/map/MapScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/stonecode/mapsroutepicker/ui/map/MapScreen.kt" />
              <option name="originalContent" value="package com.stonecode.mapsroutepicker.ui.map&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory&#10;import com.google.android.gms.maps.model.CameraPosition&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.maps.android.compose.*&#10;import com.stonecode.mapsroutepicker.ui.permissions.LocationPermissionHandler&#10;import com.stonecode.mapsroutepicker.ui.map.components.WaypointTimeline&#10;import com.stonecode.mapsroutepicker.ui.map.components.MapControlFabs&#10;import com.stonecode.mapsroutepicker.ui.map.components.SwipeableRouteInfoCard&#10;import com.stonecode.mapsroutepicker.ui.map.components.getWaypointColor&#10;import com.stonecode.mapsroutepicker.util.PolylineDecoder&#10;&#10;/**&#10; * Main map screen - displays Google Map with route, waypoints, and controls&#10; */&#10;@OptIn(ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun MapScreen(&#10;    viewModel: MapViewModel = hiltViewModel()&#10;) {&#10;    val state by viewModel.state.collectAsState()&#10;&#10;    // Debug: Log API key at runtime&#10;    LaunchedEffect(Unit) {&#10;        val apiKey = com.stonecode.mapsroutepicker.BuildConfig.MAPS_API_KEY&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; API Key in app: ${apiKey.take(10)}...&quot;)&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; Current location: ${state.currentLocation}&quot;)&#10;    }&#10;&#10;    LocationPermissionHandler(&#10;        onPermissionGranted = {&#10;            viewModel.onEvent(MapEvent.RequestLocationPermission)&#10;        },&#10;        onPermissionDenied = {&#10;            // Permission not granted, map will still work but without location&#10;        }&#10;    ) { permissionState -&gt;&#10;        if (!permissionState.allPermissionsGranted) {&#10;            // Show permission rationale&#10;            PermissionRationaleContent(&#10;                onRequestPermission = { permissionState.launchMultiplePermissionRequest() }&#10;            )&#10;        } else {&#10;            // Show main map content with system bar padding&#10;            Box(modifier = Modifier.fillMaxSize()) {&#10;                MapContent(state = state, viewModel = viewModel)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PermissionRationaleContent(&#10;    onRequestPermission: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(16.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Location Permission Required&quot;,&#10;                style = MaterialTheme.typography.headlineSmall&#10;            )&#10;            Text(&#10;                text = &quot;This app needs location access to show your current position and provide navigation.&quot;,&#10;                style = MaterialTheme.typography.bodyMedium&#10;            )&#10;            Button(onClick = onRequestPermission) {&#10;                Text(&quot;Grant Permission&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun MapContent(&#10;    state: MapState,&#10;    viewModel: MapViewModel&#10;) {&#10;    var showInitialHint by remember { mutableStateOf(true) }&#10;    var cameraPositionState: CameraPositionState? by remember { mutableStateOf(null) }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Main Google Map&#10;        GoogleMapView(&#10;            state = state,&#10;            onMapTapped = { location -&gt;&#10;                viewModel.onEvent(MapEvent.MapTapped(location))&#10;                showInitialHint = false&#10;            },&#10;            onCameraStateReady = { cameraState -&gt;&#10;                cameraPositionState = cameraState&#10;            }&#10;        )&#10;&#10;        // Route info card (TOP) - moved from bottom&#10;        if (state.error == null) {&#10;            state.route?.let { route -&gt;&#10;                SwipeableRouteInfoCard(&#10;                    route = route,&#10;                    onClose = {&#10;                        viewModel.onEvent(MapEvent.ClearRoute)&#10;                        showInitialHint = true&#10;                    },&#10;                    modifier = Modifier&#10;                        .align(Alignment.TopCenter)&#10;                        .statusBarsPadding()&#10;                        .padding(start = 16.dp, top = 16.dp, end = 16.dp)&#10;                        .fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;&#10;        // Waypoint timeline - below route card if exists&#10;        if (state.waypoints.isNotEmpty()) {&#10;            WaypointTimeline(&#10;                waypoints = state.waypoints,&#10;                onRemoveWaypoint = { waypointId -&gt;&#10;                    viewModel.onEvent(MapEvent.RemoveWaypoint(waypointId))&#10;                },&#10;                onReorderWaypoints = { reorderedWaypoints -&gt;&#10;                    viewModel.onEvent(MapEvent.ReorderWaypoints(reorderedWaypoints))&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .fillMaxWidth()&#10;                    .statusBarsPadding()&#10;                    .padding(&#10;                        start = 16.dp,&#10;                        end = 16.dp,&#10;                        top = if (state.route != null) 96.dp else 16.dp&#10;                    )&#10;            )&#10;        }&#10;&#10;        // Initial hint&#10;        if (state.error == null &amp;&amp; showInitialHint &amp;&amp; state.destination == null &amp;&amp; state.waypoints.isEmpty()) {&#10;            DismissibleInitialHint(&#10;                onDismiss = { showInitialHint = false },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .statusBarsPadding()&#10;                    .padding(16.dp)&#10;                    .fillMaxWidth()&#10;            )&#10;        }&#10;&#10;        // FAB stack (NO X BUTTON) - only show when camera is ready&#10;        cameraPositionState?.let { cameraState -&gt;&#10;            MapControlFabs(&#10;                cameraPositionState = cameraState,&#10;                onMyLocationClick = {&#10;                    state.currentLocation?.let { location -&gt;&#10;                        viewModel.onEvent(MapEvent.AnimateToLocation(location))&#10;                    }&#10;                },&#10;                onCompassClick = {&#10;                    state.currentLocation?.let { location -&gt;&#10;                        viewModel.onEvent(MapEvent.ResetCompass(location))&#10;                    }&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomEnd)&#10;                    .navigationBarsPadding()&#10;                    .padding(16.dp)&#10;            )&#10;        }&#10;&#10;        // Loading indicator&#10;        if (state.isLoading) {&#10;            LoadingOverlay()&#10;        }&#10;&#10;        // Error message&#10;        state.error?.let { error -&gt;&#10;            ErrorCard(&#10;                error = error,&#10;                onDismiss = { viewModel.onEvent(MapEvent.DismissError) },&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomCenter)&#10;                    .navigationBarsPadding()&#10;                    .padding(16.dp)&#10;                    .fillMaxWidth()&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun GoogleMapView(&#10;    state: MapState,&#10;    onMapTapped: (LatLng) -&gt; Unit,&#10;    onCameraStateReady: (CameraPositionState) -&gt; Unit = {}&#10;) {&#10;    // Default camera position (San Francisco)&#10;    val defaultLocation = LatLng(37.7749, -122.4194)&#10;    val cameraPositionState = rememberCameraPositionState {&#10;        position = CameraPosition.fromLatLngZoom(&#10;            state.currentLocation ?: defaultLocation,&#10;            12f&#10;        )&#10;    }&#10;&#10;    // Track if we've done initial zoom to user location&#10;    var hasInitiallyZoomed by remember { mutableStateOf(false) }&#10;&#10;    // Debug: Log when map is being composed&#10;    LaunchedEffect(Unit) {&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot;️ GoogleMap composable being rendered&quot;)&#10;        onCameraStateReady(cameraPositionState)&#10;    }&#10;&#10;    // Only animate to current location ONCE on initial load&#10;    LaunchedEffect(state.currentLocation) {&#10;        if (!hasInitiallyZoomed &amp;&amp; state.currentLocation != null) {&#10;            cameraPositionState.animate(&#10;                update = CameraUpdateFactory.newLatLngZoom(state.currentLocation!!, 15f),&#10;                durationMs = 1000&#10;            )&#10;            hasInitiallyZoomed = true&#10;        }&#10;    }&#10;&#10;    // Listen for camera animation requests from ViewModel&#10;    LaunchedEffect(state.cameraAnimationTarget) {&#10;        state.cameraAnimationTarget?.let { target -&gt;&#10;            cameraPositionState.animate(&#10;                update = target,&#10;                durationMs = 800&#10;            )&#10;        }&#10;    }&#10;&#10;    GoogleMap(&#10;        modifier = Modifier.fillMaxSize(),&#10;        cameraPositionState = cameraPositionState,&#10;        properties = MapProperties(&#10;            isMyLocationEnabled = state.hasLocationPermission&#10;        ),&#10;        uiSettings = MapUiSettings(&#10;            myLocationButtonEnabled = false, // Use custom FAB instead&#10;            zoomControlsEnabled = false,&#10;            compassEnabled = false // Moved to custom controls&#10;        ),&#10;        onMapClick = { location -&gt;&#10;            Log.d(&quot;MapsRoutePicker&quot;, &quot; Map tapped at: $location&quot;)&#10;            onMapTapped(location)&#10;        },&#10;        onMapLoaded = {&#10;            Log.d(&quot;MapsRoutePicker&quot;, &quot;✅ Map loaded successfully!&quot;)&#10;        }&#10;    ) {&#10;        // Destination marker&#10;        state.destination?.let { destination -&gt;&#10;            Marker(&#10;                state = MarkerState(position = destination),&#10;                title = &quot;Destination&quot;,&#10;                snippet = &quot;Your destination&quot;,&#10;                icon = BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED)&#10;            )&#10;        }&#10;&#10;        // Waypoint markers with labels (A, B, C...)&#10;        state.waypoints.sortedBy { it.order }.forEachIndexed { index, waypoint -&gt;&#10;            Marker(&#10;                state = MarkerState(position = waypoint.location),&#10;                title = &quot;Waypoint ${('A' + index)}&quot;,&#10;                snippet = &quot;Tap to remove&quot;,&#10;                icon = BitmapDescriptorFactory.defaultMarker(getMarkerHue(index))&#10;            )&#10;        }&#10;&#10;        // Color-coded route polylines for each segment&#10;        state.route?.let { route -&gt;&#10;            if (state.waypoints.isEmpty()) {&#10;                // Simple single-color route when no waypoints&#10;                val polylinePoints = PolylineDecoder.decode(route.overviewPolyline)&#10;                Polyline(&#10;                    points = polylinePoints,&#10;                    color = Color(0xFF4285F4), // Google Blue&#10;                    width = 12f&#10;                )&#10;            } else {&#10;                // Multi-colored route segments for each waypoint&#10;                route.legs.forEachIndexed { index, leg -&gt;&#10;                    leg.steps.forEach { step -&gt;&#10;                        val segmentPoints = PolylineDecoder.decode(step.polyline)&#10;                        val segmentColor = getWaypointColor(index)&#10;                        Polyline(&#10;                            points = segmentPoints,&#10;                            color = segmentColor,&#10;                            width = 12f&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Convert waypoint color to Google Maps marker hue (0-360)&#10; */&#10;private fun getMarkerHue(index: Int): Float {&#10;    val hues = listOf(&#10;        0f,    // Red&#10;        210f,  // Blue&#10;        120f,  // Green&#10;        45f,   // Orange/Amber&#10;        270f,  // Purple&#10;        30f,   // Orange&#10;        180f,  // Cyan&#10;        0f,    // Dark Red&#10;        270f,  // Deep Purple&#10;        180f   // Teal&#10;    )&#10;    return hues[index % hues.size]&#10;}&#10;&#10;@Composable&#10;private fun DismissibleInitialHint(&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.95f)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp, vertical = 12.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot; Tap anywhere on the map to set your destination&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                textAlign = TextAlign.Start,&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;            IconButton(&#10;                onClick = onDismiss,&#10;                modifier = Modifier.size(32.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;×&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LoadingOverlay() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.95f)&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                CircularProgressIndicator()&#10;                Text(&#10;                    text = &quot;Calculating route...&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ErrorCard(&#10;    error: String,&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.errorContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            verticalAlignment = Alignment.Top&#10;        ) {&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;⚠️ Error&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = error,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;&#10;                // Add helpful hints based on error type&#10;                if (error.contains(&quot;API key&quot;, ignoreCase = true)) {&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot; Fix: Run tools/fix_api_key.sh in WSL to create a valid API key&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onErrorContainer.copy(alpha = 0.8f)&#10;                    )&#10;                }&#10;            }&#10;            IconButton(onClick = onDismiss) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = &quot;Dismiss error&quot;,&#10;                    tint = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.stonecode.mapsroutepicker.ui.map&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.google.accompanist.permissions.ExperimentalPermissionsApi&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory&#10;import com.google.android.gms.maps.model.CameraPosition&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.maps.android.compose.*&#10;import com.stonecode.mapsroutepicker.ui.permissions.LocationPermissionHandler&#10;import com.stonecode.mapsroutepicker.ui.map.components.WaypointTimeline&#10;import com.stonecode.mapsroutepicker.ui.map.components.MapControlFabs&#10;import com.stonecode.mapsroutepicker.ui.map.components.SwipeableRouteInfoCard&#10;import com.stonecode.mapsroutepicker.ui.map.components.getWaypointColor&#10;import com.stonecode.mapsroutepicker.util.PolylineDecoder&#10;&#10;/**&#10; * Main map screen - displays Google Map with route, waypoints, and controls&#10; */&#10;@OptIn(ExperimentalPermissionsApi::class)&#10;@Composable&#10;fun MapScreen(&#10;    viewModel: MapViewModel = hiltViewModel()&#10;) {&#10;    val state by viewModel.state.collectAsState()&#10;&#10;    // Debug: Log API key at runtime&#10;    LaunchedEffect(Unit) {&#10;        val apiKey = com.stonecode.mapsroutepicker.BuildConfig.MAPS_API_KEY&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; API Key in app: ${apiKey.take(10)}...&quot;)&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; Current location: ${state.currentLocation}&quot;)&#10;    }&#10;&#10;    LocationPermissionHandler(&#10;        onPermissionGranted = {&#10;            viewModel.onEvent(MapEvent.RequestLocationPermission)&#10;        },&#10;        onPermissionDenied = {&#10;            // Permission not granted, map will still work but without location&#10;        }&#10;    ) { permissionState -&gt;&#10;        if (!permissionState.allPermissionsGranted) {&#10;            // Show permission rationale&#10;            PermissionRationaleContent(&#10;                onRequestPermission = { permissionState.launchMultiplePermissionRequest() }&#10;            )&#10;        } else {&#10;            // Show main map content with system bar padding&#10;            Box(modifier = Modifier.fillMaxSize()) {&#10;                MapContent(state = state, viewModel = viewModel)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun PermissionRationaleContent(&#10;    onRequestPermission: () -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(16.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Location Permission Required&quot;,&#10;                style = MaterialTheme.typography.headlineSmall&#10;            )&#10;            Text(&#10;                text = &quot;This app needs location access to show your current position and provide navigation.&quot;,&#10;                style = MaterialTheme.typography.bodyMedium&#10;            )&#10;            Button(onClick = onRequestPermission) {&#10;                Text(&quot;Grant Permission&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun MapContent(&#10;    state: MapState,&#10;    viewModel: MapViewModel&#10;) {&#10;    var showInitialHint by remember { mutableStateOf(true) }&#10;    var cameraPositionState: CameraPositionState? by remember { mutableStateOf(null) }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        // Main Google Map&#10;        GoogleMapView(&#10;            state = state,&#10;            onMapTapped = { location -&gt;&#10;                viewModel.onEvent(MapEvent.MapTapped(location))&#10;                showInitialHint = false&#10;            },&#10;            onCameraStateReady = { cameraState -&gt;&#10;                cameraPositionState = cameraState&#10;            }&#10;        )&#10;&#10;        // Route info card (TOP) - moved from bottom&#10;        if (state.error == null) {&#10;            state.route?.let { route -&gt;&#10;                SwipeableRouteInfoCard(&#10;                    route = route,&#10;                    onClose = {&#10;                        viewModel.onEvent(MapEvent.ClearRoute)&#10;                        showInitialHint = true&#10;                    },&#10;                    modifier = Modifier&#10;                        .align(Alignment.TopCenter)&#10;                        .statusBarsPadding()&#10;                        .padding(start = 16.dp, top = 16.dp, end = 16.dp)&#10;                        .fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;&#10;        // Waypoint timeline - below route card if exists&#10;        if (state.waypoints.isNotEmpty()) {&#10;            WaypointTimeline(&#10;                waypoints = state.waypoints,&#10;                onRemoveWaypoint = { waypointId -&gt;&#10;                    viewModel.onEvent(MapEvent.RemoveWaypoint(waypointId))&#10;                },&#10;                onReorderWaypoints = { reorderedWaypoints -&gt;&#10;                    viewModel.onEvent(MapEvent.ReorderWaypoints(reorderedWaypoints))&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .fillMaxWidth()&#10;                    .statusBarsPadding()&#10;                    .padding(&#10;                        start = 16.dp,&#10;                        end = 16.dp,&#10;                        top = if (state.route != null) 112.dp else 16.dp // Added more spacing from route card&#10;                    )&#10;            )&#10;        }&#10;&#10;        // Initial hint&#10;        if (state.error == null &amp;&amp; showInitialHint &amp;&amp; state.destination == null &amp;&amp; state.waypoints.isEmpty()) {&#10;            DismissibleInitialHint(&#10;                onDismiss = { showInitialHint = false },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopCenter)&#10;                    .statusBarsPadding()&#10;                    .padding(16.dp)&#10;                    .fillMaxWidth()&#10;            )&#10;        }&#10;&#10;        // FAB stack (NO X BUTTON) - only show when camera is ready&#10;        cameraPositionState?.let { cameraState -&gt;&#10;            MapControlFabs(&#10;                cameraPositionState = cameraState,&#10;                onMyLocationClick = {&#10;                    state.currentLocation?.let { location -&gt;&#10;                        viewModel.onEvent(MapEvent.AnimateToLocation(location))&#10;                    }&#10;                },&#10;                onCompassClick = {&#10;                    state.currentLocation?.let { location -&gt;&#10;                        viewModel.onEvent(MapEvent.ResetCompass(location))&#10;                    }&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomEnd)&#10;                    .navigationBarsPadding()&#10;                    .padding(16.dp)&#10;            )&#10;        }&#10;&#10;        // Loading indicator&#10;        if (state.isLoading) {&#10;            LoadingOverlay()&#10;        }&#10;&#10;        // Error message&#10;        state.error?.let { error -&gt;&#10;            ErrorCard(&#10;                error = error,&#10;                onDismiss = { viewModel.onEvent(MapEvent.DismissError) },&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomCenter)&#10;                    .navigationBarsPadding()&#10;                    .padding(16.dp)&#10;                    .fillMaxWidth()&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun GoogleMapView(&#10;    state: MapState,&#10;    onMapTapped: (LatLng) -&gt; Unit,&#10;    onCameraStateReady: (CameraPositionState) -&gt; Unit = {}&#10;) {&#10;    // Default camera position (San Francisco)&#10;    val defaultLocation = LatLng(37.7749, -122.4194)&#10;    val cameraPositionState = rememberCameraPositionState {&#10;        position = CameraPosition.fromLatLngZoom(&#10;            state.currentLocation ?: defaultLocation,&#10;            12f&#10;        )&#10;    }&#10;&#10;    // Track if we've done initial zoom to user location&#10;    var hasInitiallyZoomed by remember { mutableStateOf(false) }&#10;&#10;    // Debug: Log when map is being composed&#10;    LaunchedEffect(Unit) {&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot;️ GoogleMap composable being rendered&quot;)&#10;        onCameraStateReady(cameraPositionState)&#10;    }&#10;&#10;    // Only animate to current location ONCE on initial load&#10;    LaunchedEffect(state.currentLocation) {&#10;        if (!hasInitiallyZoomed &amp;&amp; state.currentLocation != null) {&#10;            cameraPositionState.animate(&#10;                update = CameraUpdateFactory.newLatLngZoom(state.currentLocation!!, 15f),&#10;                durationMs = 1000&#10;            )&#10;            hasInitiallyZoomed = true&#10;        }&#10;    }&#10;&#10;    // Listen for camera animation requests from ViewModel&#10;    LaunchedEffect(state.cameraAnimationTarget) {&#10;        state.cameraAnimationTarget?.let { target -&gt;&#10;            cameraPositionState.animate(&#10;                update = target,&#10;                durationMs = 800&#10;            )&#10;        }&#10;    }&#10;&#10;    GoogleMap(&#10;        modifier = Modifier.fillMaxSize(),&#10;        cameraPositionState = cameraPositionState,&#10;        properties = MapProperties(&#10;            isMyLocationEnabled = state.hasLocationPermission&#10;        ),&#10;        uiSettings = MapUiSettings(&#10;            myLocationButtonEnabled = false, // Use custom FAB instead&#10;            zoomControlsEnabled = false,&#10;            compassEnabled = false // Moved to custom controls&#10;        ),&#10;        onMapClick = { location -&gt;&#10;            Log.d(&quot;MapsRoutePicker&quot;, &quot; Map tapped at: $location&quot;)&#10;            onMapTapped(location)&#10;        },&#10;        onMapLoaded = {&#10;            Log.d(&quot;MapsRoutePicker&quot;, &quot;✅ Map loaded successfully!&quot;)&#10;        }&#10;    ) {&#10;        // Destination marker&#10;        state.destination?.let { destination -&gt;&#10;            Marker(&#10;                state = MarkerState(position = destination),&#10;                title = &quot;Destination&quot;,&#10;                snippet = &quot;Your destination&quot;,&#10;                icon = BitmapDescriptorFactory.defaultMarker(BitmapDescriptorFactory.HUE_RED)&#10;            )&#10;        }&#10;&#10;        // Waypoint markers with labels (A, B, C...)&#10;        state.waypoints.sortedBy { it.order }.forEachIndexed { index, waypoint -&gt;&#10;            Marker(&#10;                state = MarkerState(position = waypoint.location),&#10;                title = &quot;Waypoint ${('A' + index)}&quot;,&#10;                snippet = &quot;Tap to remove&quot;,&#10;                icon = BitmapDescriptorFactory.defaultMarker(getMarkerHue(index))&#10;            )&#10;        }&#10;&#10;        // Color-coded route polylines for each segment&#10;        state.route?.let { route -&gt;&#10;            if (state.waypoints.isEmpty()) {&#10;                // Simple single-color route when no waypoints&#10;                val polylinePoints = PolylineDecoder.decode(route.overviewPolyline)&#10;                Polyline(&#10;                    points = polylinePoints,&#10;                    color = Color(0xFF4285F4), // Google Blue&#10;                    width = 12f&#10;                )&#10;            } else {&#10;                // Multi-colored route segments for each waypoint&#10;                route.legs.forEachIndexed { index, leg -&gt;&#10;                    leg.steps.forEach { step -&gt;&#10;                        val segmentPoints = PolylineDecoder.decode(step.polyline)&#10;                        val segmentColor = getWaypointColor(index)&#10;                        Polyline(&#10;                            points = segmentPoints,&#10;                            color = segmentColor,&#10;                            width = 12f&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Convert waypoint color to Google Maps marker hue (0-360)&#10; */&#10;private fun getMarkerHue(index: Int): Float {&#10;    val hues = listOf(&#10;        0f,    // Red&#10;        210f,  // Blue&#10;        120f,  // Green&#10;        45f,   // Orange/Amber&#10;        270f,  // Purple&#10;        30f,   // Orange&#10;        180f,  // Cyan&#10;        0f,    // Dark Red&#10;        270f,  // Deep Purple&#10;        180f   // Teal&#10;    )&#10;    return hues[index % hues.size]&#10;}&#10;&#10;@Composable&#10;private fun DismissibleInitialHint(&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.95f)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp, vertical = 12.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot; Tap anywhere on the map to set your destination&quot;,&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                color = MaterialTheme.colorScheme.onPrimaryContainer,&#10;                textAlign = TextAlign.Start,&#10;                modifier = Modifier.weight(1f)&#10;            )&#10;            IconButton(&#10;                onClick = onDismiss,&#10;                modifier = Modifier.size(32.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;×&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    color = MaterialTheme.colorScheme.onPrimaryContainer&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun LoadingOverlay() {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Card(&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.95f)&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                CircularProgressIndicator()&#10;                Text(&#10;                    text = &quot;Calculating route...&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun ErrorCard(&#10;    error: String,&#10;    onDismiss: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.errorContainer&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            verticalAlignment = Alignment.Top&#10;        ) {&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;⚠️ Error&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;                Spacer(modifier = Modifier.height(4.dp))&#10;                Text(&#10;                    text = error,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;&#10;                // Add helpful hints based on error type&#10;                if (error.contains(&quot;API key&quot;, ignoreCase = true)) {&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Text(&#10;                        text = &quot; Fix: Run tools/fix_api_key.sh in WSL to create a valid API key&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onErrorContainer.copy(alpha = 0.8f)&#10;                    )&#10;                }&#10;            }&#10;            IconButton(onClick = onDismiss) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = &quot;Dismiss error&quot;,&#10;                    tint = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/stonecode/mapsroutepicker/ui/map/MapViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/stonecode/mapsroutepicker/ui/map/MapViewModel.kt" />
              <option name="originalContent" value="package com.stonecode.mapsroutepicker.ui.map&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.stonecode.mapsroutepicker.domain.model.Waypoint&#10;import com.stonecode.mapsroutepicker.domain.repository.LocationRepository&#10;import com.stonecode.mapsroutepicker.domain.repository.RoutingRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for the map screen&#10; * Manages route state, waypoints, and interactions with routing repository&#10; */&#10;@HiltViewModel&#10;class MapViewModel @Inject constructor(&#10;    private val locationRepository: LocationRepository,&#10;    private val routingRepository: RoutingRepository&#10;) : ViewModel() {&#10;&#10;    private val _state = MutableStateFlow(MapState())&#10;    val state: StateFlow&lt;MapState&gt; = _state.asStateFlow()&#10;&#10;    init {&#10;        // Location updates will start when permission is granted&#10;    }&#10;&#10;    fun onEvent(event: MapEvent) {&#10;        when (event) {&#10;            is MapEvent.MapTapped -&gt; handleMapTap(event.location)&#10;            is MapEvent.SetDestination -&gt; setDestination(event.location)&#10;            is MapEvent.AddWaypoint -&gt; addWaypoint(event.location)&#10;            is MapEvent.RemoveWaypoint -&gt; removeWaypoint(event.waypointId)&#10;            is MapEvent.ReorderWaypoints -&gt; reorderWaypoints(event.waypoints)&#10;            is MapEvent.ClearRoute -&gt; clearRoute()&#10;            is MapEvent.RequestLocationPermission -&gt; requestLocationPermission()&#10;            is MapEvent.ToggleDestinationInput -&gt; toggleDestinationInput()&#10;            is MapEvent.DismissError -&gt; dismissError()&#10;            is MapEvent.AnimateToLocation -&gt; animateToLocation(event.location)&#10;            is MapEvent.ResetCompass -&gt; resetCompass(event.location)&#10;        }&#10;    }&#10;&#10;    private fun handleMapTap(location: LatLng) {&#10;        val currentState = _state.value&#10;&#10;        when {&#10;            // If no destination, set it&#10;            currentState.destination == null -&gt; {&#10;                setDestination(location)&#10;            }&#10;            // If destination exists, add as waypoint&#10;            else -&gt; {&#10;                addWaypoint(location)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setDestination(location: LatLng) {&#10;        _state.update { it.copy(&#10;            destination = location,&#10;            showDestinationInput = false&#10;        )}&#10;&#10;        // Calculate route if we have current location&#10;        if (_state.value.currentLocation != null) {&#10;            calculateRoute()&#10;        }&#10;    }&#10;&#10;    private fun addWaypoint(location: LatLng) {&#10;        val currentWaypoints = _state.value.waypoints&#10;        val newWaypoint = Waypoint(&#10;            location = location,&#10;            order = currentWaypoints.size + 1,&#10;            isLocked = true&#10;        )&#10;&#10;        _state.update { it.copy(&#10;            waypoints = currentWaypoints + newWaypoint&#10;        )}&#10;&#10;        // Recalculate route with new waypoint&#10;        calculateRoute()&#10;    }&#10;&#10;    private fun removeWaypoint(waypointId: String) {&#10;        val updatedWaypoints = _state.value.waypoints&#10;            .filterNot { it.id == waypointId }&#10;            .mapIndexed { index, waypoint -&gt;&#10;                waypoint.copy(order = index + 1)&#10;            }&#10;&#10;        _state.update { it.copy(waypoints = updatedWaypoints) }&#10;&#10;        // Recalculate route without removed waypoint&#10;        if (updatedWaypoints.isNotEmpty() || _state.value.destination != null) {&#10;            calculateRoute()&#10;        }&#10;    }&#10;&#10;    private fun reorderWaypoints(waypoints: List&lt;Waypoint&gt;) {&#10;        val reorderedWaypoints = waypoints.mapIndexed { index, waypoint -&gt;&#10;            waypoint.copy(order = index + 1)&#10;        }&#10;&#10;        _state.update { it.copy(waypoints = reorderedWaypoints) }&#10;&#10;        // Recalculate route with new order&#10;        calculateRoute()&#10;    }&#10;&#10;    private fun clearRoute() {&#10;        _state.update { it.copy(&#10;            destination = null,&#10;            route = null,&#10;            waypoints = emptyList(),&#10;            error = null&#10;        )}&#10;    }&#10;&#10;    private fun calculateRoute() {&#10;        val currentState = _state.value&#10;&#10;        // Need at least origin and destination&#10;        if (currentState.currentLocation == null || currentState.destination == null) {&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _state.update { it.copy(isLoading = true, error = null) }&#10;&#10;            try {&#10;                val route = routingRepository.getRoute(&#10;                    origin = currentState.currentLocation!!,&#10;                    destination = currentState.destination!!,&#10;                    waypoints = currentState.waypoints&#10;                )&#10;                _state.update { it.copy(route = route, isLoading = false) }&#10;&#10;            } catch (e: Exception) {&#10;                _state.update { it.copy(&#10;                    isLoading = false,&#10;                    error = &quot;Failed to calculate route: ${e.message}&quot;&#10;                )}&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestLocationPermission() {&#10;        _state.update { it.copy(hasLocationPermission = true) }&#10;&#10;        // Start location updates when permission is granted&#10;        startLocationUpdates()&#10;    }&#10;&#10;    private fun startLocationUpdates() {&#10;        viewModelScope.launch {&#10;            // Get current location first&#10;            locationRepository.getCurrentLocation()?.let { location -&gt;&#10;                _state.update { it.copy(currentLocation = location) }&#10;            }&#10;&#10;            // Then start continuous updates&#10;            locationRepository.getLocationUpdates().collect { location -&gt;&#10;                onLocationUpdate(location)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun toggleDestinationInput() {&#10;        _state.update { it.copy(&#10;            showDestinationInput = !it.showDestinationInput&#10;        )}&#10;    }&#10;&#10;    private fun onLocationUpdate(location: LatLng) {&#10;        _state.update { it.copy(currentLocation = location) }&#10;&#10;        // If we have a destination but no route yet, calculate it&#10;        if (_state.value.destination != null &amp;&amp; _state.value.route == null) {&#10;            calculateRoute()&#10;        }&#10;    }&#10;&#10;    private fun dismissError() {&#10;        _state.update { it.copy(error = null) }&#10;    }&#10;&#10;    private fun animateToLocation(location: LatLng) {&#10;        // Camera animation will be handled in the composable&#10;        // This event is mainly for future extensions&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; Animating to location: $location&quot;)&#10;        &#10;        val cameraUpdate = com.google.android.gms.maps.CameraUpdateFactory.newLatLngZoom(location, 15f)&#10;        _state.update { it.copy(cameraAnimationTarget = cameraUpdate) }&#10;        &#10;        // Clear the target after triggering&#10;        viewModelScope.launch {&#10;            kotlinx.coroutines.delay(100)&#10;            _state.update { it.copy(cameraAnimationTarget = null) }&#10;        }&#10;    }&#10;&#10;    private fun resetCompass(location: LatLng) {&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; Resetting compass to north and centering on location: $location&quot;)&#10;        &#10;        // Reset bearing to 0 (north) and tilt to 0 (flat), zoom to 15&#10;        val cameraPosition = com.google.android.gms.maps.model.CameraPosition.Builder()&#10;            .target(location)&#10;            .zoom(15f)&#10;            .bearing(0f)&#10;            .tilt(0f)&#10;            .build()&#10;        &#10;        val cameraUpdate = com.google.android.gms.maps.CameraUpdateFactory.newCameraPosition(cameraPosition)&#10;        _state.update { it.copy(cameraAnimationTarget = cameraUpdate) }&#10;        &#10;        // Clear the target after triggering&#10;        viewModelScope.launch {&#10;            kotlinx.coroutines.delay(100)&#10;            _state.update { it.copy(cameraAnimationTarget = null) }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.stonecode.mapsroutepicker.ui.map&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.stonecode.mapsroutepicker.domain.model.Waypoint&#10;import com.stonecode.mapsroutepicker.domain.repository.LocationRepository&#10;import com.stonecode.mapsroutepicker.domain.repository.RoutingRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;/**&#10; * ViewModel for the map screen&#10; * Manages route state, waypoints, and interactions with routing repository&#10; */&#10;@HiltViewModel&#10;class MapViewModel @Inject constructor(&#10;    private val locationRepository: LocationRepository,&#10;    private val routingRepository: RoutingRepository&#10;) : ViewModel() {&#10;&#10;    private val _state = MutableStateFlow(MapState())&#10;    val state: StateFlow&lt;MapState&gt; = _state.asStateFlow()&#10;&#10;    init {&#10;        // Location updates will start when permission is granted&#10;    }&#10;&#10;    fun onEvent(event: MapEvent) {&#10;        when (event) {&#10;            is MapEvent.MapTapped -&gt; handleMapTap(event.location)&#10;            is MapEvent.SetDestination -&gt; setDestination(event.location)&#10;            is MapEvent.AddWaypoint -&gt; addWaypoint(event.location)&#10;            is MapEvent.RemoveWaypoint -&gt; removeWaypoint(event.waypointId)&#10;            is MapEvent.ReorderWaypoints -&gt; reorderWaypoints(event.waypoints)&#10;            is MapEvent.ClearRoute -&gt; clearRoute()&#10;            is MapEvent.RequestLocationPermission -&gt; requestLocationPermission()&#10;            is MapEvent.ToggleDestinationInput -&gt; toggleDestinationInput()&#10;            is MapEvent.DismissError -&gt; dismissError()&#10;            is MapEvent.AnimateToLocation -&gt; animateToLocation(event.location)&#10;            is MapEvent.ResetCompass -&gt; resetCompass(event.location)&#10;        }&#10;    }&#10;&#10;    private fun handleMapTap(location: LatLng) {&#10;        val currentState = _state.value&#10;&#10;        when {&#10;            // If no destination, set it&#10;            currentState.destination == null -&gt; {&#10;                setDestination(location)&#10;            }&#10;            // If destination exists, add as waypoint&#10;            else -&gt; {&#10;                addWaypoint(location)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setDestination(location: LatLng) {&#10;        _state.update { it.copy(&#10;            destination = location,&#10;            showDestinationInput = false&#10;        )}&#10;&#10;        // Calculate route if we have current location&#10;        if (_state.value.currentLocation != null) {&#10;            calculateRoute()&#10;        }&#10;    }&#10;&#10;    private fun addWaypoint(location: LatLng) {&#10;        val currentWaypoints = _state.value.waypoints&#10;        val newWaypoint = Waypoint(&#10;            location = location,&#10;            order = currentWaypoints.size + 1,&#10;            isLocked = true&#10;        )&#10;&#10;        _state.update { it.copy(&#10;            waypoints = currentWaypoints + newWaypoint&#10;        )}&#10;&#10;        // Recalculate route with new waypoint&#10;        calculateRoute()&#10;    }&#10;&#10;    private fun removeWaypoint(waypointId: String) {&#10;        val updatedWaypoints = _state.value.waypoints&#10;            .filterNot { it.id == waypointId }&#10;            .mapIndexed { index, waypoint -&gt;&#10;                waypoint.copy(order = index + 1)&#10;            }&#10;&#10;        _state.update { it.copy(waypoints = updatedWaypoints) }&#10;&#10;        // Recalculate route without removed waypoint&#10;        if (updatedWaypoints.isNotEmpty() || _state.value.destination != null) {&#10;            calculateRoute()&#10;        }&#10;    }&#10;&#10;    private fun reorderWaypoints(waypoints: List&lt;Waypoint&gt;) {&#10;        val reorderedWaypoints = waypoints.mapIndexed { index, waypoint -&gt;&#10;            waypoint.copy(order = index + 1)&#10;        }&#10;&#10;        _state.update { it.copy(waypoints = reorderedWaypoints) }&#10;&#10;        // Recalculate route with new order&#10;        calculateRoute()&#10;    }&#10;&#10;    private fun clearRoute() {&#10;        _state.update { it.copy(&#10;            destination = null,&#10;            route = null,&#10;            waypoints = emptyList(),&#10;            error = null&#10;        )}&#10;    }&#10;&#10;    private fun calculateRoute() {&#10;        val currentState = _state.value&#10;&#10;        // Need at least origin and destination&#10;        if (currentState.currentLocation == null || currentState.destination == null) {&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _state.update { it.copy(isLoading = true, error = null) }&#10;&#10;            try {&#10;                val route = routingRepository.getRoute(&#10;                    origin = currentState.currentLocation!!,&#10;                    destination = currentState.destination!!,&#10;                    waypoints = currentState.waypoints&#10;                )&#10;                _state.update { it.copy(route = route, isLoading = false) }&#10;&#10;            } catch (e: Exception) {&#10;                _state.update { it.copy(&#10;                    isLoading = false,&#10;                    error = &quot;Failed to calculate route: ${e.message}&quot;&#10;                )}&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestLocationPermission() {&#10;        _state.update { it.copy(hasLocationPermission = true) }&#10;&#10;        // Start location updates when permission is granted&#10;        startLocationUpdates()&#10;    }&#10;&#10;    private fun startLocationUpdates() {&#10;        viewModelScope.launch {&#10;            // Get current location first&#10;            locationRepository.getCurrentLocation()?.let { location -&gt;&#10;                _state.update { it.copy(currentLocation = location) }&#10;            }&#10;&#10;            // Then start continuous updates&#10;            locationRepository.getLocationUpdates().collect { location -&gt;&#10;                onLocationUpdate(location)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun toggleDestinationInput() {&#10;        _state.update { it.copy(&#10;            showDestinationInput = !it.showDestinationInput&#10;        )}&#10;    }&#10;&#10;    private fun onLocationUpdate(location: LatLng) {&#10;        _state.update { it.copy(currentLocation = location) }&#10;&#10;        // If we have a destination but no route yet, calculate it&#10;        if (_state.value.destination != null &amp;&amp; _state.value.route == null) {&#10;            calculateRoute()&#10;        }&#10;    }&#10;&#10;    private fun dismissError() {&#10;        _state.update { it.copy(error = null) }&#10;    }&#10;&#10;    private fun animateToLocation(location: LatLng) {&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; Animating to location: $location&quot;)&#10;        &#10;        val cameraUpdate = com.google.android.gms.maps.CameraUpdateFactory.newLatLngZoom(location, 16f)&#10;        _state.update { it.copy(cameraAnimationTarget = cameraUpdate) }&#10;        &#10;        // Clear the target after animation completes&#10;        viewModelScope.launch {&#10;            kotlinx.coroutines.delay(1000) // Wait for 800ms animation + buffer&#10;            _state.update { it.copy(cameraAnimationTarget = null) }&#10;        }&#10;    }&#10;&#10;    private fun resetCompass(location: LatLng) {&#10;        Log.d(&quot;MapsRoutePicker&quot;, &quot; Resetting compass to north and centering on location: $location&quot;)&#10;        &#10;        // Reset bearing to 0 (north) and tilt to 0 (flat), zoom to 16&#10;        val cameraPosition = com.google.android.gms.maps.model.CameraPosition.Builder()&#10;            .target(location)&#10;            .zoom(16f)&#10;            .bearing(0f)&#10;            .tilt(0f)&#10;            .build()&#10;        &#10;        val cameraUpdate = com.google.android.gms.maps.CameraUpdateFactory.newCameraPosition(cameraPosition)&#10;        _state.update { it.copy(cameraAnimationTarget = cameraUpdate) }&#10;        &#10;        // Clear the target after animation completes&#10;        viewModelScope.launch {&#10;            kotlinx.coroutines.delay(1000) // Wait for 800ms animation + buffer&#10;            _state.update { it.copy(cameraAnimationTarget = null) }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/stonecode/mapsroutepicker/ui/map/components/SwipeableRouteInfoCard.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/stonecode/mapsroutepicker/ui/map/components/SwipeableRouteInfoCard.kt" />
              <option name="originalContent" value="package com.stonecode.mapsroutepicker.ui.map.components&#10;&#10;import androidx.compose.animation.core.SpringSpec&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.input.pointer.util.VelocityTracker&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.stonecode.mapsroutepicker.domain.model.Route&#10;import kotlin.math.abs&#10;import kotlin.math.roundToInt&#10;&#10;/**&#10; * Route info card with swipe-to-reveal close button&#10; * Features: 200dp swipe distance, spring physics, velocity tracking, haptic feedback&#10; */&#10;@Composable&#10;fun SwipeableRouteInfoCard(&#10;    route: Route,&#10;    onClose: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var offsetX by remember { mutableStateOf(0f) }&#10;    var isRevealed by remember { mutableStateOf(false) }&#10;    val haptic = LocalHapticFeedback.current&#10;    val velocityTracker = remember { VelocityTracker() }&#10;&#10;    // Spring animation for smooth, bouncy feel&#10;    val animatedOffset by animateFloatAsState(&#10;        targetValue = if (isRevealed) -200f else 0f,&#10;        animationSpec = spring(&#10;            dampingRatio = 0.7f,&#10;            stiffness = 300f&#10;        ),&#10;        label = &quot;card_swipe&quot;&#10;    )&#10;&#10;    Box(&#10;        modifier = modifier&#10;    ) {&#10;        // Background close button (revealed when swiped)&#10;        if (isRevealed) {&#10;            FilledTonalButton(&#10;                onClick = {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                    onClose()&#10;                    isRevealed = false&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterEnd)&#10;                    .size(80.dp)&#10;                    .padding(8.dp),&#10;                colors = ButtonDefaults.filledTonalButtonColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer,&#10;                    contentColor = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = &quot;Close route&quot;,&#10;                    modifier = Modifier.size(40.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Main card content&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .offset { IntOffset(animatedOffset.roundToInt(), 0) }&#10;                .pointerInput(Unit) {&#10;                    detectHorizontalDragGestures(&#10;                        onDragStart = {&#10;                            velocityTracker.resetTracking()&#10;                        },&#10;                        onDragEnd = {&#10;                            val velocity = velocityTracker.calculateVelocity().x&#10;&#10;                            // Fling detection: fast swipe triggers reveal&#10;                            val shouldReveal = if (abs(velocity) &gt; 1000f) {&#10;                                velocity &lt; -500f // Swiping left fast&#10;                            } else {&#10;                                offsetX &lt; -100f // Dragged past halfway&#10;                            }&#10;&#10;                            if (shouldReveal != isRevealed) {&#10;                                haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            }&#10;&#10;                            isRevealed = shouldReveal&#10;                            offsetX = 0f&#10;                        },&#10;                        onDragCancel = {&#10;                            isRevealed = false&#10;                            offsetX = 0f&#10;                        },&#10;                        onHorizontalDrag = { change, dragAmount -&gt;&#10;                            change.consume()&#10;                            velocityTracker.addPosition(&#10;                                change.uptimeMillis,&#10;                                change.position&#10;                            )&#10;&#10;                            offsetX += dragAmount&#10;                            // Only allow left swipe, constrain to 0 to -220&#10;                            offsetX = offsetX.coerceIn(-220f, 0f)&#10;&#10;                            // Haptic feedback when crossing reveal threshold&#10;                            if (!isRevealed &amp;&amp; offsetX &lt; -100f) {&#10;                                haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            }&#10;                        }&#10;                    )&#10;                },&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),&#10;            onClick = {&#10;                // Tap to hide close button if revealed&#10;                if (isRevealed) {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    isRevealed = false&#10;                }&#10;            }&#10;        ) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = route.summary ?: &quot;Route&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    Row(&#10;                        horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot; ${route.getFormattedDistance()}&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            fontWeight = FontWeight.Medium,&#10;                            color = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                        Text(&#10;                            text = &quot;⏱️ ${route.getFormattedDuration()}&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            fontWeight = FontWeight.Medium,&#10;                            color = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Swipe hint indicator - pulses to show it's swipeable&#10;                Text(&#10;                    text = if (isRevealed) &quot;◄&quot; else &quot;◄◄&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = if (isRevealed) 0.3f else 0.5f),&#10;                    modifier = Modifier.alpha(if (isRevealed) 0.3f else 0.7f)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.stonecode.mapsroutepicker.ui.map.components&#10;&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.input.pointer.util.VelocityTracker&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.dp&#10;import com.stonecode.mapsroutepicker.domain.model.Route&#10;import kotlin.math.abs&#10;import kotlin.math.roundToInt&#10;&#10;/**&#10; * Route info card with swipe-to-reveal close button&#10; * Features: 200dp swipe distance, spring physics, velocity tracking, reduced haptic feedback&#10; */&#10;@Composable&#10;fun SwipeableRouteInfoCard(&#10;    route: Route,&#10;    onClose: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var dragOffsetX by remember { mutableStateOf(0f) }&#10;    var isRevealed by remember { mutableStateOf(false) }&#10;    var wasRevealed by remember { mutableStateOf(false) }&#10;    val haptic = LocalHapticFeedback.current&#10;    val velocityTracker = remember { VelocityTracker() }&#10;&#10;    // Spring animation only when not dragging&#10;    val animatedOffset by animateFloatAsState(&#10;        targetValue = if (isRevealed &amp;&amp; dragOffsetX == 0f) -200f else dragOffsetX,&#10;        animationSpec = spring(&#10;            dampingRatio = 0.7f,&#10;            stiffness = 300f&#10;        ),&#10;        label = &quot;card_swipe&quot;&#10;    )&#10;&#10;    Box(&#10;        modifier = modifier&#10;    ) {&#10;        // Background close button (shows as you drag or when revealed)&#10;        if (isRevealed || dragOffsetX &lt; -50f) {&#10;            val buttonAlpha = if (dragOffsetX &lt; 0f) {&#10;                (abs(dragOffsetX) / 200f).coerceIn(0f, 1f)&#10;            } else if (isRevealed) {&#10;                1f&#10;            } else {&#10;                0f&#10;            }&#10;&#10;            FilledTonalButton(&#10;                onClick = {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                    onClose()&#10;                    isRevealed = false&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterEnd)&#10;                    .size(80.dp)&#10;                    .padding(8.dp)&#10;                    .alpha(buttonAlpha),&#10;                colors = ButtonDefaults.filledTonalButtonColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer,&#10;                    contentColor = MaterialTheme.colorScheme.onErrorContainer&#10;                )&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Default.Close,&#10;                    contentDescription = &quot;Close route&quot;,&#10;                    modifier = Modifier.size(40.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Main card content&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .offset { IntOffset(animatedOffset.roundToInt(), 0) }&#10;                .pointerInput(Unit) {&#10;                    detectHorizontalDragGestures(&#10;                        onDragStart = {&#10;                            velocityTracker.resetTracking()&#10;                            wasRevealed = isRevealed&#10;                        },&#10;                        onDragEnd = {&#10;                            val velocity = velocityTracker.calculateVelocity().x&#10;&#10;                            // Fling detection: fast swipe triggers reveal&#10;                            val shouldReveal = if (abs(velocity) &gt; 1000f) {&#10;                                velocity &lt; -500f // Swiping left fast&#10;                            } else {&#10;                                dragOffsetX &lt; -100f // Dragged past halfway&#10;                            }&#10;&#10;                            // Only haptic feedback when state changes&#10;                            if (shouldReveal != wasRevealed) {&#10;                                haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            }&#10;&#10;                            isRevealed = shouldReveal&#10;                            dragOffsetX = 0f&#10;                        },&#10;                        onDragCancel = {&#10;                            isRevealed = wasRevealed&#10;                            dragOffsetX = 0f&#10;                        },&#10;                        onHorizontalDrag = { change, dragAmount -&gt;&#10;                            change.consume()&#10;                            velocityTracker.addPosition(&#10;                                change.uptimeMillis,&#10;                                change.position&#10;                            )&#10;&#10;                            dragOffsetX += dragAmount&#10;                            // Only allow left swipe, constrain to 0 to -220&#10;                            dragOffsetX = dragOffsetX.coerceIn(-220f, 0f)&#10;                        }&#10;                    )&#10;                },&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface&#10;            ),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),&#10;            onClick = {&#10;                // Tap to hide close button if revealed&#10;                if (isRevealed) {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    isRevealed = false&#10;                }&#10;            }&#10;        ) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = route.summary ?: &quot;Route&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.onSurface&#10;                    )&#10;                    Spacer(modifier = Modifier.height(4.dp))&#10;                    Row(&#10;                        horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot; ${route.getFormattedDistance()}&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            fontWeight = FontWeight.Medium,&#10;                            color = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                        Text(&#10;                            text = &quot;⏱️ ${route.getFormattedDuration()}&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge,&#10;                            fontWeight = FontWeight.Medium,&#10;                            color = MaterialTheme.colorScheme.onSurface&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Swipe hint indicator - pulses to show it's swipeable&#10;                Text(&#10;                    text = if (isRevealed) &quot;◄&quot; else &quot;◄◄&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = if (isRevealed) 0.3f else 0.5f),&#10;                    modifier = Modifier.alpha(if (isRevealed) 0.3f else 0.7f)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>